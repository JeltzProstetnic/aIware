#!/usr/bin/env python3
"""Build POD book covers (front cover + full wrap) for US and EU editions.

Usage:
  python3 tmp/build_book_cover.py --edition us     # US front cover
  python3 tmp/build_book_cover.py --edition eu     # EU front cover
  python3 tmp/build_book_cover.py --edition all    # Both editions
  python3 tmp/build_book_cover.py --edition us --wrap  # Full wrap (back+spine+front)
  python3 tmp/build_book_cover.py --kindle         # Kindle front cover (1600x2560 JPG)
"""

import argparse
import os
import subprocess
import shutil
from PIL import Image
from PIL.PngImagePlugin import PngInfo

# Paths
COVER_IMAGE = "/home/jeltz/aIware/figures/art-consciousness-large.png"
OUTPUT_DIR = "/home/jeltz/aIware/pop-sci"
FIGURES_DIR = "/home/jeltz/aIware/figures"

# Bleed: 0.125" on each side (KDP/IngramSpark standard)
BLEED = 0.125

# Edition configs
EDITIONS = {
    "us": {
        "label": "US Trade 6\"×9\" Paperback",
        "trim_w": 6.0,   # inches
        "trim_h": 9.0,
        "pages": 251,
        "paper_thickness": 0.002252,  # white paper (KDP)
        "suffix": "",
        "hardcover": False,
        "isbn": "9798249169121",
    },
    "us-hc": {
        "label": "US 6\"×9\" Hardcover",
        "trim_w": 6.0,
        "trim_h": 9.0,
        "pages": 251,
        "paper_thickness": 0.002252,  # white paper (KDP)
        "suffix": "-hc",
        "hardcover": True,
        # Case laminate geometry (reverse-engineered from KDP calculator output):
        # Layout L→R: [wrap][board(trim+oh)][joint][spine][joint][board(trim+oh)][wrap]
        # Width  = 2*wrap + 2*(trim_w + overhang_w) + 2*joint + spine
        # Height = 2*wrap + trim_h + 2*overhang_h
        # For 251pp white: 14.329" × 10.417" (confirmed by KDP rejection feedback)
        "case_wrap": 0.591,        # turn-in wrap on each edge (15mm)
        "case_joint": 0.197,       # joint gap board↔spine, each side (5mm)
        "case_overhang_w": 0.094,  # board extends beyond pages L/R (2.4mm)
        "case_overhang_h": 0.1175, # board extends beyond pages T/B (≈3mm)
        "isbn": "9798249172268",
    },
    "eu": {
        "label": "European 15.5×23cm Paperback",
        "trim_w": 155 / 25.4,  # 6.102"
        "trim_h": 230 / 25.4,  # 9.055"
        "pages": 251,
        "paper_thickness": 0.002252,  # white paper
        "suffix": "-eu",
        "hardcover": False,
        "isbn": "[TBD-EU]",
    },
}

BACK_COVER_BLURB = r"""You are a simulation.

Not a metaphor. Not a philosophical thought experiment. A literal, running simulation ---
generated by your brain, updated hundreds of times per second, experienced from the inside.

This book presents a unified theory of consciousness built on four models the brain maintains:
two of the world (one learned, one simulated) and two of the self (one learned, one simulated).
The theory dissolves the ``hard problem,'' explains psychedelic phenomenology, predicts
nine testable outcomes, and provides a concrete blueprint for building a conscious machine.

If the theory is right, consciousness was never mysterious. It was just mislabeled."""

BACK_COVER_TAGLINE = r"""\textit{``The most ambitious theory of consciousness I've encountered\\from outside the academy.''} --- Review pending"""


def crop_for_front_cover(img, trim_w, trim_h, dpi=300):
    """Crop the image for front cover, focusing on the right side (neural eye)."""
    target_w = int((trim_w + 2 * BLEED) * dpi)
    target_h = int((trim_h + 2 * BLEED) * dpi)

    img_w, img_h = img.size

    # Scale to fill height
    scale = target_h / img_h
    scaled_w = int(img_w * scale)
    scaled_h = target_h
    img_scaled = img.resize((scaled_w, scaled_h), Image.LANCZOS)

    # Position crop so the neural eye glint is just within the right edge.
    # The right edge of the visible area in the ORIGINAL image is at x=4264.
    # Scale that to match the scaled image coordinates.
    img_w_orig = img.size[0]
    right_frac = 4264 / img_w_orig  # fraction of original image width
    right_edge = int(scaled_w * right_frac)
    left = max(0, right_edge - target_w)
    if left + target_w > scaled_w:
        left = scaled_w - target_w
    return img_scaled.crop((left, 0, left + target_w, scaled_h))


def crop_for_wrap(img, total_w_in, trim_h, dpi=300):
    """Crop the image for full wrap (back + spine + front)."""
    target_w = int((total_w_in + 2 * BLEED) * dpi)
    target_h = int((trim_h + 2 * BLEED) * dpi)

    img_w, img_h = img.size

    # Scale to fill height
    scale = target_h / img_h
    scaled_w = int(img_w * scale)
    scaled_h = target_h
    img_scaled = img.resize((scaled_w, scaled_h), Image.LANCZOS)

    # Center crop for wrap
    left = max(0, (scaled_w - target_w) // 2)
    return img_scaled.crop((left, 0, left + target_w, scaled_h))


def build_front_cover_tex(edition):
    """Generate LaTeX for front cover."""
    ed = EDITIONS[edition]
    cover_w = ed["trim_w"] + 2 * BLEED
    cover_h = ed["trim_h"] + 2 * BLEED
    img_name = f"cover-front{ed['suffix']}.jpg"

    return r"""\documentclass[border=0pt]{standalone}
\usepackage[T1]{fontenc}
\usepackage{palatino}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}

\begin{document}
\begin{tikzpicture}

% Black background (eliminates any edge gaps from rounding)
\fill[black] (0,0) rectangle (""" + f"{cover_w}" + r"""in, """ + f"{cover_h}" + r"""in);

% Background image (full bleed)
\node[inner sep=0pt, outer sep=0pt] at (""" + f"{cover_w/2}" + r"""in, """ + f"{cover_h/2}" + r"""in) {
  \includegraphics[width=""" + f"{cover_w}" + r"""in, height=""" + f"{cover_h}" + r"""in]{""" + img_name + r"""}
};

% Dark gradient overlay at top — covers title + subtitle, fades before neural eye
\fill[top color=black!90, bottom color=black!0, opacity=0.70]
  (0in, """ + f"{cover_h * 0.68}" + r"""in)
  rectangle (""" + f"{cover_w}" + r"""in, """ + f"{cover_h}" + r"""in);

% Subtle dark gradient at bottom for author name
\fill[bottom color=black!80, top color=black!0, opacity=0.65]
  (0in, 0in)
  rectangle (""" + f"{cover_w}" + r"""in, """ + f"{BLEED + 1.2}" + r"""in);

% Title
\node[anchor=north, text=white, font=\fontsize{36}{42}\selectfont\bfseries,
      text width=""" + f"{ed['trim_w'] - 1.0}" + r"""in, align=center]
  at (""" + f"{cover_w/2}" + r"""in, """ + f"{cover_h - BLEED - 0.6}" + r"""in)
  {The Simulation\\[0.15in] You Call ``I''};

% Subtitle (tucked close under title, within gradient zone)
\node[anchor=north, text=white!90, font=\fontsize{14}{18}\selectfont,
      text width=""" + f"{ed['trim_w'] - 1.2}" + r"""in, align=center]
  at (""" + f"{cover_w/2}" + r"""in, """ + f"{cover_h - BLEED - 2.2}" + r"""in)
  {The Architecture of Consciousness,\\Computation, and the Cosmos};

% Author name
\node[anchor=south, text=white!95, font=\fontsize{18}{22}\selectfont]
  at (""" + f"{cover_w/2}" + r"""in, """ + f"{BLEED + 0.5}" + r"""in)
  {Matthias Gruber};

\end{tikzpicture}
\end{document}
"""


def get_wrap_dimensions(edition):
    """Calculate wrap dimensions for paperback or hardcover."""
    ed = EDITIONS[edition]
    spine_w = ed["pages"] * ed["paper_thickness"]

    if ed.get("hardcover"):
        # Hardcover case laminate:
        # Layout L→R: [wrap][board(trim+oh)][joint][spine][joint][board(trim+oh)][wrap]
        wrap = ed["case_wrap"]           # 0.591
        joint = ed["case_joint"]         # 0.197
        oh_w = ed["case_overhang_w"]     # 0.094
        oh_h = ed["case_overhang_h"]     # 0.1175
        board_w = ed["trim_w"] + oh_w
        total_w = 2 * wrap + 2 * board_w + 2 * joint + spine_w
        total_h = 2 * wrap + ed["trim_h"] + 2 * oh_h
        # Content margins: wrap + overhang = distance from cover edge to trim area
        margin_x = wrap + oh_w
        margin_y = wrap + oh_h
        back_center_x = margin_x + ed["trim_w"] / 2
        spine_left = margin_x + ed["trim_w"] + joint
        spine_center_x = spine_left + spine_w / 2
        front_left = spine_left + spine_w + joint
        front_center_x = front_left + ed["trim_w"] / 2
        barcode_x = margin_x + ed["trim_w"] - 1.2
        barcode_y = margin_y + 0.76
        text_safe = 0.635
    else:
        # Paperback: simple layout with bleed
        total_w = ed["trim_w"] * 2 + spine_w + 2 * BLEED
        total_h = ed["trim_h"] + 2 * BLEED
        margin_x = BLEED
        margin_y = BLEED
        back_center_x = BLEED + ed["trim_w"] / 2
        spine_left = BLEED + ed["trim_w"]
        spine_center_x = BLEED + ed["trim_w"] + spine_w / 2
        front_left = BLEED + ed["trim_w"] + spine_w
        front_center_x = BLEED + ed["trim_w"] + spine_w + ed["trim_w"] / 2
        barcode_x = BLEED + ed["trim_w"] - 1.2
        barcode_y = BLEED + 0.5
        text_safe = 0.5

    return {
        "total_w": total_w, "total_h": total_h, "spine_w": spine_w,
        "margin_x": margin_x, "margin_y": margin_y,
        "back_center_x": back_center_x,
        "spine_left": spine_left, "spine_center_x": spine_center_x,
        "front_left": front_left, "front_center_x": front_center_x,
        "barcode_x": barcode_x, "barcode_y": barcode_y,
        "text_safe": text_safe,
    }


def build_wrap_tex(edition):
    """Generate LaTeX for full wrap (back + spine + front)."""
    ed = EDITIONS[edition]
    d = get_wrap_dimensions(edition)
    total_w = d["total_w"]
    total_h = d["total_h"]
    spine_w = d["spine_w"]
    mx = d["margin_x"]  # horizontal content margin (wrap + board overhang for HC)
    my = d["margin_y"]  # vertical content margin
    back_center_x = d["back_center_x"]
    spine_center_x = d["spine_center_x"]
    front_center_x = d["front_center_x"]
    front_left = d["front_left"]
    spine_left = d["spine_left"]
    barcode_x = d["barcode_x"]
    barcode_y = d["barcode_y"]
    img_name = f"cover-wrap{ed['suffix']}.jpg"

    # ISBN barcode image: use edition-specific barcode
    isbn = ed.get("isbn", "")
    barcode_img = f"isbn-barcode{ed['suffix']}.png"

    return r"""\documentclass[border=0pt]{standalone}
\usepackage[T1]{fontenc}
\usepackage{palatino}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{xcolor}

\begin{document}
\begin{tikzpicture}

% Black background
\fill[black] (0,0) rectangle (""" + f"{total_w}" + r"""in, """ + f"{total_h}" + r"""in);

% Background image (full bleed)
\node[inner sep=0pt, outer sep=0pt] at (""" + f"{total_w/2}" + r"""in, """ + f"{total_h/2}" + r"""in) {
  \includegraphics[width=""" + f"{total_w}" + r"""in, height=""" + f"{total_h}" + r"""in]{""" + img_name + r"""}
};

% ---- FRONT COVER (right side) ----

% Dark gradient at top — covers title + subtitle, fades before neural eye
\fill[top color=black!90, bottom color=black!0, opacity=0.70]
  (""" + f"{front_left}" + r"""in, """ + f"{total_h * 0.68}" + r"""in)
  rectangle (""" + f"{total_w}" + r"""in, """ + f"{total_h}" + r"""in);

% Gradient at bottom for author
\fill[bottom color=black!80, top color=black!0, opacity=0.65]
  (""" + f"{front_left}" + r"""in, 0in)
  rectangle (""" + f"{total_w}" + r"""in, """ + f"{my + 1.2}" + r"""in);

% Front title
\node[anchor=north, text=white, font=\fontsize{36}{42}\selectfont\bfseries,
      text width=""" + f"{ed['trim_w'] - 1.0}" + r"""in, align=center]
  at (""" + f"{front_center_x}" + r"""in, """ + f"{total_h - my - 0.6}" + r"""in)
  {The Simulation\\[0.15in] You Call ``I''};

% Front subtitle (within gradient zone)
\node[anchor=north, text=white!90, font=\fontsize{14}{18}\selectfont,
      text width=""" + f"{ed['trim_w'] - 1.2}" + r"""in, align=center]
  at (""" + f"{front_center_x}" + r"""in, """ + f"{total_h - my - 2.2}" + r"""in)
  {The Architecture of Consciousness,\\Computation, and the Cosmos};

% Front author
\node[anchor=south, text=white!95, font=\fontsize{18}{22}\selectfont]
  at (""" + f"{front_center_x}" + r"""in, """ + f"{my + 0.5}" + r"""in)
  {Matthias Gruber};

% ---- SPINE ----

% Dark overlay on spine + hinge zones for readability
\fill[black, opacity=0.5]
  (""" + f"{spine_left}" + r"""in, 0in)
  rectangle (""" + f"{spine_left + spine_w}" + r"""in, """ + f"{total_h}" + r"""in);

% Spine text (rotated)
\node[rotate=270, text=white, font=\fontsize{10}{12}\selectfont\bfseries,
      anchor=center]
  at (""" + f"{spine_center_x}" + r"""in, """ + f"{total_h/2 + 0.5}" + r"""in)
  {The Simulation You Call ``I''};

\node[rotate=270, text=white!90, font=\fontsize{8}{10}\selectfont,
      anchor=center]
  at (""" + f"{spine_center_x}" + r"""in, """ + f"{total_h/2 - 1.5}" + r"""in)
  {Matthias Gruber};

% ---- BACK COVER (left side) ----

% Dark overlay on back cover for text
\fill[black, opacity=0.55]
  (""" + f"{mx}" + r"""in, """ + f"{my}" + r"""in)
  rectangle (""" + f"{mx + ed['trim_w']}" + r"""in, """ + f"{total_h - my}" + r"""in);

% Back cover blurb
\node[anchor=north, text=white!95, font=\fontsize{11}{15}\selectfont,
      text width=""" + f"{ed['trim_w'] - 1.4}" + r"""in, align=left]
  at (""" + f"{back_center_x}" + r"""in, """ + f"{total_h - my - 1.0}" + r"""in)
  {""" + BACK_COVER_BLURB + r"""};

% ISBN barcode (white background box + barcode image)
\fill[white] (""" + f"{barcode_x - 1.0}" + r"""in, """ + f"{barcode_y - 0.15}" + r"""in)
  rectangle (""" + f"{barcode_x + 1.0}" + r"""in, """ + f"{barcode_y + 1.05}" + r"""in);
\node[inner sep=0pt] at (""" + f"{barcode_x}" + r"""in, """ + f"{barcode_y + 0.45}" + r"""in)
  {\includegraphics[width=1.8in]{""" + barcode_img + r"""}};

\end{tikzpicture}
\end{document}
"""


def generate_barcode_for_edition(edition):
    """Generate ISBN barcode PNG for the given edition."""
    ed = EDITIONS[edition]
    isbn = ed.get("isbn", "")
    if not isbn or isbn.startswith("["):
        return None  # No ISBN yet

    import barcode
    from barcode.writer import ImageWriter

    barcode_name = f"isbn-barcode{ed['suffix']}"
    barcode_path = os.path.join(OUTPUT_DIR, barcode_name)
    ean = barcode.get('ean13', isbn[:12], writer=ImageWriter())
    ean.save(barcode_path, options={
        'module_width': 0.4,
        'module_height': 20,
        'font_size': 14,
        'text_distance': 5,
        'quiet_zone': 6.5,
        'dpi': 300,
    })
    print(f"  Barcode generated: {barcode_path}.png (ISBN {isbn})")
    return f"{barcode_name}.png"


def build_cover(edition, wrap=False):
    """Build a cover for the given edition."""
    ed = EDITIONS[edition]
    suffix = ed["suffix"]
    spine_w = ed["pages"] * ed["paper_thickness"]

    print(f"\n{'='*60}")
    kind = "full wrap" if wrap else "front cover"
    print(f"Building {kind}: {ed['label']}")
    print(f"  Spine width: {spine_w:.3f}\" ({ed['pages']} pages × {ed['paper_thickness']})")
    if ed.get("hardcover"):
        d = get_wrap_dimensions(edition)
        print(f"  Case laminate: {d['total_w']:.3f}\" × {d['total_h']:.3f}\"")
    print(f"{'='*60}")

    # Generate barcode for this edition if needed for wrap
    if wrap:
        generate_barcode_for_edition(edition)

    # Load and crop the image
    img = Image.open(COVER_IMAGE)
    print(f"  Source image: {img.size[0]}×{img.size[1]} px")

    if wrap:
        d = get_wrap_dimensions(edition)
        # For image cropping, use total cover dimensions (BLEED added inside crop_for_wrap)
        cropped = crop_for_wrap(img, d["total_w"], d["total_h"])
        img_name = f"cover-wrap{suffix}.jpg"
        tex_content = build_wrap_tex(edition)
        tex_name = f"cover-wrap{suffix}.tex"
    else:
        cropped = crop_for_front_cover(img, ed["trim_w"], ed["trim_h"])
        img_name = f"cover-front{suffix}.jpg"
        tex_content = build_front_cover_tex(edition)
        tex_name = f"cover-front{suffix}.tex"

    # Save cropped image
    img_path = os.path.join(OUTPUT_DIR, img_name)
    cropped.save(img_path, quality=95)
    print(f"  Cropped image: {cropped.size[0]}×{cropped.size[1]} px → {img_name}")

    # Write LaTeX
    tex_path = os.path.join(OUTPUT_DIR, tex_name)
    with open(tex_path, 'w') as f:
        f.write(tex_content)

    # Compile
    print("  Compiling PDF...")
    result = subprocess.run(
        ['pdflatex', '-interaction=nonstopmode', '-output-directory', OUTPUT_DIR, tex_path],
        capture_output=True, cwd=OUTPUT_DIR, timeout=60
    )

    pdf_name = tex_name.replace('.tex', '.pdf')
    pdf_path = os.path.join(OUTPUT_DIR, pdf_name)
    if os.path.exists(pdf_path):
        size_kb = os.path.getsize(pdf_path) / 1024
        print(f"  SUCCESS: {pdf_path} ({size_kb:.0f} KB)")

        # Copy to Windows desktop
        win_path = f"/mnt/c/Users/Matthias/Desktop/{pdf_name}"
        try:
            shutil.copy2(pdf_path, win_path)
            print(f"  Copied to: {win_path}")
        except Exception as e:
            print(f"  Note: Could not copy to desktop: {e}")
        return True
    else:
        print("  FAILED")
        log_path = tex_path.replace('.tex', '.log')
        if os.path.exists(log_path):
            with open(log_path, 'r', errors='replace') as f:
                log = f.read()
            errors = [l for l in log.split('\n') if l.startswith('!')]
            for e in errors[:10]:
                print(f"  ERROR: {e}")
        return False


KINDLE_ALT_TEXT = (
    "You are a simulation. "
    "Not a metaphor. Not a philosophical thought experiment. A literal, running simulation — "
    "generated by your brain, updated hundreds of times per second, experienced from the inside. "
    "This book presents a unified theory of consciousness built on four models the brain maintains: "
    "two of the world (one learned, one simulated) and two of the self (one learned, one simulated). "
    "The theory dissolves the 'hard problem,' explains psychedelic phenomenology, predicts "
    "nine testable outcomes, and provides a concrete blueprint for building a conscious machine. "
    "If the theory is right, consciousness was never mysterious. It was just mislabeled."
)


def build_kindle_cover():
    """Build Kindle front cover: 1600×2560 JPG at 99% quality.

    Strategy: render the US front cover PDF at high DPI via PyMuPDF,
    then resize to height=2560 and center-crop to 1600 wide.
    """
    import fitz  # PyMuPDF

    print(f"\n{'='*60}")
    print("Building Kindle front cover (1600×2560 JPG)")
    print(f"{'='*60}")

    # First build the US front cover PDF (reuse existing logic)
    ok = build_cover("us", wrap=False)
    if not ok:
        print("  FAILED: could not build base front cover PDF")
        return False

    pdf_path = os.path.join(OUTPUT_DIR, "cover-front.pdf")
    doc = fitz.open(pdf_path)
    page = doc[0]

    # Page dimensions in points (72 pt/inch)
    page_rect = page.rect
    page_w_pt = page_rect.width
    page_h_pt = page_rect.height

    # Calculate zoom to get exactly 2560 px height
    target_h = 2560
    target_w = 1600
    zoom_y = target_h / page_h_pt
    zoom_x = zoom_y  # uniform scaling
    mat = fitz.Matrix(zoom_x, zoom_y)

    pix = page.get_pixmap(matrix=mat, alpha=False)
    rendered_w = pix.width
    rendered_h = pix.height
    print(f"  Rendered: {rendered_w}×{rendered_h} px")

    # Convert to PIL for cropping
    img = Image.frombytes("RGB", [rendered_w, rendered_h], pix.samples)
    doc.close()

    # Crop from left only — preserve the right edge (glint positioning)
    if rendered_w > target_w:
        left = rendered_w - target_w
        img = img.crop((left, 0, rendered_w, rendered_h))
    elif rendered_w < target_w:
        # Shouldn't happen with 6.25" cover, but pad with black if needed
        padded = Image.new("RGB", (target_w, rendered_h), (0, 0, 0))
        offset = (target_w - rendered_w) // 2
        padded.paste(img, (offset, 0))
        img = padded

    # Ensure exact dimensions
    if img.size != (target_w, target_h):
        img = img.resize((target_w, target_h), Image.LANCZOS)

    print(f"  Final: {img.size[0]}×{img.size[1]} px")

    # Save as JPG at 99% quality with EXIF ImageDescription (alt text)
    jpg_path = os.path.join(OUTPUT_DIR, "cover-kindle.jpg")
    exif = img.getexif()
    exif[0x010E] = KINDLE_ALT_TEXT  # EXIF ImageDescription tag
    img.save(jpg_path, "JPEG", quality=99, subsampling=0, exif=exif.tobytes())
    print("  Alt text embedded via EXIF ImageDescription")

    size_kb = os.path.getsize(jpg_path) / 1024
    print(f"  SUCCESS: {jpg_path} ({size_kb:.0f} KB)")

    # Copy to desktop
    win_path = f"/mnt/c/Users/Matthias/Desktop/cover-kindle.jpg"
    try:
        shutil.copy2(jpg_path, win_path)
        print(f"  Copied to: {win_path}")
    except Exception as e:
        print(f"  Note: Could not copy to desktop: {e}")

    return True


def main():
    parser = argparse.ArgumentParser(description="Build POD book covers")
    parser.add_argument('--edition', choices=['us', 'us-hc', 'eu', 'all'], default='us',
                        help='Edition: us (paperback), us-hc (hardcover), eu, or all')
    parser.add_argument('--wrap', action='store_true',
                        help='Build full wrap (back+spine+front) instead of front cover only')
    parser.add_argument('--kindle', action='store_true',
                        help='Build Kindle front cover (1600×2560 JPG)')
    args = parser.parse_args()

    if args.kindle:
        ok = build_kindle_cover()
        print(f"\n{'='*60}")
        print(f"  Kindle cover: {'OK' if ok else 'FAILED'}")
        print(f"{'='*60}")
        return

    editions = ['us', 'us-hc', 'eu'] if args.edition == 'all' else [args.edition]
    results = {}
    for ed in editions:
        results[ed] = build_cover(ed, wrap=args.wrap)

    print(f"\n{'='*60}")
    for ed, ok in results.items():
        status = "OK" if ok else "FAILED"
        print(f"  {EDITIONS[ed]['label']}: {status}")
    print(f"{'='*60}")


if __name__ == '__main__':
    main()
